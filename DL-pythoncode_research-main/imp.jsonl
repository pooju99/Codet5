{"text": "Write a function to reverse a linked list.", "code": "class Node: \r\n\tdef __init__(self, val=0, next=None):\r\n\t\tself.val = val\r\n\t\tself.next = next\r\n\r\ndef reverse_linked_list(head):\r\n\tif not head or not head.next:\r\n\t\treturn head\r\n\tnew_head = reverse_linked_list(head.next)\r\n\thead.next.next = head\r\n\thead.next = None\r\n\treturn new_head", "task_id": 975, "test_setup_code": "class TestLinkedList:\n\tdef __init__(self, values):\n\t\tself.head = None\n\t\tif values:\n\t\t\tself.head = Node(values[0])\n\t\t\tcurrent = self.head\n\t\t\tfor value in values[1:]:\n\t\t\t\tcurrent.next = Node(value)\n\t\t\t\tcurrent = current.next\n\n", "test_list": ["linked_list = TestLinkedList([1, 2, 3, 4, 5])\nreverse_linked_list(linked_list.head)\nassert linked_list.head.val == 5\nassert linked_list.head.next.val == 4\nassert linked_list.head.next.next.val == 3\nassert linked_list.head.next.next.next.val == 2\nassert linked_list.head.next.next.next.next.val == 1", "linked_list = TestLinkedList([1, 2, 3])\nreverse_linked_list(linked_list.head)\nassert linked_list.head.val == 3\nassert linked_list.head.next.val == 2\nassert linked_list.head.next.next.val == 1", "linked_list = TestLinkedList([1])\nreverse_linked_list(linked_list.head)\nassert linked_list.head.val == 1"], "challenge_test_list": []}
{"text": "Wrtie a function for two sum question", "code": "def twoSum(nums, target):\n d = {}\n for i, num in enumerate(nums):\n if target - num in d:\n return [d[target - num], i]\n d[num] = i\n return []", "task_id": 1, "test_setup_code": "", "test_list": ["assert twoSum([2,7,11,15], 9) == [0,1]", "assert twoSum([3,2,4], 6) == [1,2]", "assert twoSum([3,3], 6) == [0,1]"], "challenge_test_list": []}
{"text": "Wrtie a function to find the longest palindromic subsequence's length .", "code": "def longestPalindromeSubseq(s: str) -> int: \r\n n = len(s) \r\n dp = [[0]*n for _ in range(n)] \r\n for i in range(n-1, -1, -1): \r\n dp[i][i] = 1 \r\n for j in range(i+1, n): \r\n if s[i] == s[j]: \r\n dp[i][j] = dp[i+1][j-1] + 2 \r\n else: \r\n dp[i][j] = max(dp[i+1][j], dp[i][j-1]) \r\n return dp[0][-1]", "task_id": 1025, "test_setup_code": "", "test_list": ["assert longestPalindromeSubseq('bbbab') == 4", "assert longestPalindromeSubseq('cbbd') == 2", "assert longestPalindromeSubseq('a') == 1"], "challenge_test_list": []}
{"text": "Wrtie a function to find the median of the two sorted arrays.", "code": "", "task_id": 4, "test_setup_code": "", "test_list": ["assert findMedianSortedArrays([1, 3], [2]) == 2.0", "assert findMedianSortedArrays([1, 2], [3, 4]) == 2.5", "assert findMedianSortedArrays([0, 0], [0, 0]) == 0.0", "assert findMedianSortedArrays([], [1]) == 1.0", "assert findMedianSortedArrays([2], []) == 2.0"], "challenge_test_list": []}
{"text": "Write a function to find longest substring without repeating characters.", "code": "def lengthOfLongestSubstring(s):\n chars = {}\n left = 0\n right = 0\n res = 0\n while right < len(s):\n if s[right] in chars and chars[s[right]] >= left:\n left = chars[s[right]] + 1\n chars[s[right]] = right\n res = max(res, right - left + 1)\n right += 1\n return res", "task_id": 3, "test_setup_code": "", "test_list": ["assert lengthOfLongestSubstring('abcabcbb') == 3", "assert lengthOfLongestSubstring('bbbbb') == 1", "assert lengthOfLongestSubstring('pwwkew') == 3"], "challenge_test_list": []}
{"text": "Write a Python function to convert a string into a zigzag pattern based on a given number of rows. ", "code": "def convert(s: str, numRows: int) -> str:\n    if numRows == 1:\n        return s\n    rows = ['' for _ in range(numRows)]\n    row = 0\n    direction = -1\n    for c in s:\n        rows[row] += c\n        if row == 0 or row == numRows - 1:\n            direction *= -1\n        row += direction\n    return ''.join(rows)","test_setup_code": "test_cases = [(\"PAYPALISHIRING\", 3, \"PAHNAPLSIIGYIR\"),\n              (\"PAYPALISHIRING\", 4, \"PINALSIGYAHRPI\"),\n              (\"A\", 1, \"A\")]", "test_list": [], "challenge_test_list": []}
{"text": "Write a function to reverse a given 32-bit signed integer.", "code": "def reverse(x):\n if x >= 0:\n sign = 1\n else:\n sign = -1\n x = -x\n reversed_x = int(str(x)[::-1])\n if reversed_x > (2**31 - 1):\n return 0\n return reversed_x * sign", "task_id": 7, "test_setup_code": "test_cases = [\n (123, 321),\n (-123, -321),\n (120, 21),\n (0, 0)\n]", "test_list": ["for x, expected in test_cases:\n assert reverse(x) == expected"], "challenge_test_list": []}
{"text": "Write a Python function to implement the String to Integer (atoi) conversion.", "code": "class Solution:\n def myAtoi(self, s: str) -> int:\n s = s.strip()\n if not s: return 0\n\n sign = -1 if s[0] == '-' else 1\n if s[0] in ['-', '+']: s = s[1:]\n\n res, i = 0, 0\n while i < len(s) and s[i].isdigit():\n res = res * 10 + ord(s[i]) - ord('0')\n i += 1\n\n return max(-231, min(sign * res, 231 - 1))", "task_id": 875, "test_setup_code": "s = Solution()", "test_list": ["assert s.myAtoi('42') == 42", "assert s.myAtoi(' -42') == -42", "assert s.myAtoi('4193 with words') == 4193", "assert s.myAtoi('words and 987') == 0", "assert s.myAtoi('-91283472332') == -2147483648", "assert s.myAtoi('3.14159') == 3", "assert s.myAtoi('+-12') == 0"], "challenge_test_list": []}
{"text": "Write a function to check if a given integer is a palindrome or not.", "code": "class Solution:\n def isPalindrome(self, x: int) -> bool:\n if x < 0:\n return False\n reverse_x, orig_x = 0, x\n while x > 0:\n reverse_x = reverse_x * 10 + x % 10\n x //= 10\n return reverse_x == orig_x", "task_id": 0, "test_setup_code": "s = Solution()", "test_list": ["assert s.isPalindrome(121) == True", "assert s.isPalindrome(-121) == False", "assert s.isPalindrome(10) == False"], "challenge_test_list": []}
{"text": "Write a function to Regular Expression Matching", "code": "def isMatch(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[m][n]", "task_id": 10, "test_setup_code": "testCases = [(\"aa\", \"a*\", True), (\"mississippi\", \"mis*is*p*.\", False), (\"aab\", \"c*a*b\", True)]", "test_list": ["assert isMatch(testCases[0][0], testCases[0][1]) == testCases[0][2]", "assert isMatch(testCases[1][0], testCases[1][1]) == testCases[1][2]", "assert isMatch(testCases[2][0], testCases[2][1]) == testCases[2][2]"], "challenge_test_list": []}
{"text": "Write a Python function to find the container with the most water ", "code": "def maxArea(height):\n left = 0\n right = len(height)-1\n max_area = 0\n while left < right:\n current_area = min(height[left], height[right]) * (right - left)\n max_area = max(max_area, current_area)\n if height[left] < height[right]:\n left += 1\n else:\n right -= 1\n return max_area", "task_id": 1771, "test_setup_code": "", "test_list": ["assert maxArea([1,8,6,2,5,4,8,3,7]) == 49", "assert maxArea([1,1]) == 1", "assert maxArea([4,3,2,1,4]) == 16"], "challenge_test_list": []}
{"text": "Write a Python function to convert an integer to a roman numeral.", "code": "class Solution:\n def intToRoman(self, num: int) -> str:\n roman_numeral = ''\n roman_numerals = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n for i in roman_numerals:\n while num >= i:\n roman_numeral += roman_numerals[i]\n num -= i\n return roman_numeral", "task_id": 0, "test_setup_code": "", "test_list": ["assert Solution().intToRoman(3) == 'III'", "assert Solution().intToRoman(4) == 'IV'", "assert Solution().intToRoman(9) == 'IX'", "assert Solution().intToRoman(58) == 'LVIII'", "assert Solution().intToRoman(1994) == 'MCMXCIV'"], "challenge_test_list": []}
{"text": "Write a Python function to convert a Roman numeral string to an integer.", "code": "class Solution:\n def romanToInt(self, s: str) -> int:\n symbols = {\n 'I': 1,\n 'V': 5,\n 'X': 10,\n 'L': 50,\n 'C': 100,\n 'D': 500,\n 'M': 1000\n }\n total = 0\n prev = 0\n for c in s:\n current = symbols[c]\n if current > prev:\n total += current - 2 * prev\n else:\n total += current\n prev = current\n return total\n", "task_id": 0, "test_setup_code": "", "test_list": ["assert Solution().romanToInt('III') == 3", "assert Solution().romanToInt('IV') == 4", "assert Solution().romanToInt('IX') == 9", "assert Solution().romanToInt('LVIII') == 58", "assert Solution().romanToInt('MCMXCIV') == 1994"], "challenge_test_list": []}
{"text": "Write a Python function to find the 3sum question", "code": "def threeSum(nums):\n result = []\n nums.sort()\n for i in range(len(nums)-2):\n if i > 0 and nums[i] == nums[i-1]:\n continue\n left, right = i+1, len(nums)-1\n while left < right:\n s = nums[i] + nums[left] + nums[right]\n if s < 0:\n left += 1\n elif s > 0:\n right -= 1\n else:\n result.append([nums[i], nums[left], nums[right]])\n while left < right and nums[left] == nums[left+1]:\n left += 1\n while left < right and nums[right] == nums[right-1]:\n right -= 1\n left += 1\n right -= 1\n return result", "task_id": 984, "test_setup_code": "", "test_list": ["assert sorted(threeSum([-1,0,1,2,-1,-4])) == [[-1,-1,2],[-1,0,1]]", "assert sorted(threeSum([-2,0,0,2,2])) == [[-2,0,2],[0,0,0],[0,2,2]]", "assert threeSum([1,2,-2,-1]) == []"], "challenge_test_list": []}
{"text": "Write a function to find the sum of three integers in a given array closest to a target value.", "code": "def three_sum_closest(nums, target):\n nums.sort()\n res = float('inf')\n n = len(nums)\n for i in range(n-2):\n l, r = i+1, n-1\n while l<r:\n s = nums[i] + nums[l] + nums[r]\n if abs(s-target) < abs(res-target):\n res = s\n if s < target:\n l += 1\n else:\n r -= 1\n return res", "task_id": 155, "test_setup_code": "", "test_list": ["assert three_sum_closest([-1, 2, 1, -4], 1) == 2", "assert three_sum_closest([1, 1, 1, 0], -100) == 2", "assert three_sum_closest([1, 1, -1], 0) == 1"], "challenge_test_list": []}
{"text": "Wrtie a python function for letter combination of a phone number","code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        num_to_char = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        result = ['']\n        for digit in digits:\n            temp = []\n            for char in num_to_char[digit]:\n                for combination in result:\n                    temp.append(combination + char)\n            result = temp\n        return result\n", "test_setup_code": "", "test_list": ["assert sol.letterCombinations('23') == ['ad','ae','af','bd','be','bf','cd','ce','cf']","assert sol.letterCombinations('2') == ['a', 'b', 'c']","assert sol.letterCombinations('9') == ['w', 'x', 'y', 'z']"], "challenge_test_list": []}
{"text": "Write a Python function to find all unique quadruplets in the array which gives the sum of target.", "code": "def fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums)-3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        for j in range(i+1, len(nums)-2):\n            if j > i+1 and nums[j] == nums[j-1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n    return result", "test_setup_code": "from itertools import combinations\nfrom random import randint\n\ndef brute_force(nums, target):\n    result = []\n    for combination in combinations(nums, 4):\n        if sum(combination) == target:\n            result.append(list(combination))\n    return result\n\nnums = [randint(-1000, 1000) for i in range(100)]\ntarget = randint(-5000, 5000)\nexpected = sorted(brute_force(nums, target))", "test_list": ["assert sorted(fourSum(nums, target)) == expected"], "challenge_test_list": []}
{"text": "Write a Python function to find the median of two sorted arrays.", "code": "def findMedianSortedArrays(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    if m > n:\n        nums1, nums2, m, n = nums2, nums1, n, m\n    i_min, i_max, half_len = 0, m, (m + n + 1) // 2\n    while i_min <= i_max:\n        i = (i_min + i_max) // 2\n        j = half_len - i\n        if i < m and nums2[j - 1] > nums1[i]:\n            i_min = i + 1\n        elif i > 0 and nums1[i - 1] > nums2[j]:\n            i_max = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n            if (m + n) % 2 == 1:\n                return max_of_left\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n            return (max_of_left + min_of_right) / 2.0", "task_id": 2, "test_setup_code": "", "test_list": ["assert findMedianSortedArrays([1, 3], [2]) == 2.0", "assert findMedianSortedArrays([1, 2], [3, 4]) == 2.5"], "challenge_test_list": []}
{"text": "Write a Python function to merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.", "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(l1, l2):\n    if not l1:\n        return l2\n    if not l2:\n        return l1\n    if l1.val <= l2.val:\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    else:\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2", "task_id": 3, "test_setup_code": "", "test_list": ["assert mergeTwoLists(ListNode(1, ListNode(2, ListNode(4))), ListNode(1, ListNode(3, ListNode(4)))).val == 1", "assert mergeTwoLists(ListNode(1, ListNode(2, ListNode(4))), ListNode(1, ListNode(3, ListNode(4)))).next.val == 1"], "challenge_test_list": []}
{"text": "Write a Python function to generate all combinations of well-formed parentheses given a number n. Each combination should be a valid parentheses string.", "code": "def generateParenthesis(n):\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    result = []\n    backtrack('', 0, 0)\n    return result", "task_id": 4, "test_setup_code": "", "test_list": ["assert generateParenthesis(3) == ['((()))', '(()())', '(())()', '()(())', '()()()']", "assert generateParenthesis(1) == ['()']"], "challenge_test_list": []}
{"text": "Write a Python function to merge k sorted linked lists and return it as a sorted list.", "code": "from heapq import heappush, heappop\n\ndef mergeKLists(lists):\n    heap = []\n    for i, node in enumerate(lists):\n        if node:\n            heappush(heap, (node.val, i))\n    dummy = ListNode(0)\n    curr = dummy\n    while heap:\n        val, i = heappop(heap)\n        curr.next = ListNode(val)\n        curr = curr.next\n        if lists[i].next:\n            lists[i] = lists[i].next\n            heappush(heap, (lists[i].val, i))\n    return dummy.next", "task_id": 3, "test_setup_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next", "test_list": ["list1 = ListNode(1, ListNode(4, ListNode(5)))\nlist2 = ListNode(1, ListNode(3, ListNode(4)))\nlist3 = ListNode(2, ListNode(6))\nassert mergeKLists([list1, list2, list3]) == [1, 1, 2, 3, 4, 4, 5, 6]", "assert mergeKLists([]) == []"], "challenge_test_list": []}
{"text": "Write a Python function to swap every two adjacent nodes in a linked list and return its head.", "code": "def swapPairs(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    while head and head.next:\n        first_node = head\n        second_node = head.next\n        prev.next = second_node\n        first_node.next = second_node.next\n        second_node.next = first_node\n        prev = first_node\n        head = first_node.next\n    return dummy.next", "task_id": 4, "test_setup_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next", "test_list": ["list1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))\nassert swapPairs(list1) == [2, 1, 4, 3]", "list2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nassert swapPairs(list2) == [2, 1, 4, 3, 5]"], "challenge_test_list": []}
{"text": "Write a Python function to reverse the nodes of a linked list, k nodes at a time, and return its modified head.", "code": "def reverseKGroup(head, k):\n    def reverseList(head):\n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return prev\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    while head:\n        tail = prev\n        for _ in range(k):\n            tail = tail.next\n            if not tail:\n                return dummy.next\n        next_head = tail.next\n        sub_list_head = head\n        sub_list_tail = tail\n        tail.next = None\n        head = next_head\n        prev.next = reverseList(sub_list_head)\n        sub_list_head.next = head\n        prev = sub_list_tail\n    return dummy.next", "task_id": 5, "test_setup_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next", "test_list": ["list1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nassert reverseKGroup(list1, 2) == [2, 1, 4, 3, 5]", "list2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nassert reverseKGroup(list2, 3) == [3, 2, 1, 4, 5]"], "challenge_test_list": []}
{"text": "Write a Python function to remove the duplicates in-place from a sorted array and return the new length.", "code": "def removeDuplicates(nums):\n    if not nums:\n        return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1", "task_id": 6, "test_setup_code": "", "test_list": ["nums1 = [1, 1, 2]\nassert removeDuplicates(nums1) == 2", "nums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\nassert removeDuplicates(nums2) == 5"], "challenge_test_list": []}
{"text": "Write a Python function to remove all occurrences of a given value in-place from an array and return the new length.", "code": "def removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i", "task_id": 7, "test_setup_code": "", "test_list": ["nums1 = [3, 2, 2, 3]\nval1 = 3\nassert removeElement(nums1, val1) == 2", "nums2 = [0, 1, 2, 2, 3, 0, 4, 2]\nval2 = 2\nassert removeElement(nums2, val2) == 5"], "challenge_test_list": []}
{"text": "Write a Python function to find the index of the first occurrence of a substring in a given string, or return -1 if the substring is not found.", "code": "def strStr(haystack, needle):\n    if needle == '':\n        return 0\n    for i in range(len(haystack) - len(needle) + 1):\n        if haystack[i:i+len(needle)] == needle:\n            return i\n    return -1", "task_id": 8, "test_setup_code": "", "test_list": ["haystack1 = 'hello'\nneedle1 = 'll'\nassert strStr(haystack1, needle1) == 2", "haystack2 = 'aaaaa'\nneedle2 = 'bba'\nassert strStr(haystack2, needle2) == -1"], "challenge_test_list": []}
{"text": "Write a Python function to divide two integers without using multiplication, division, and mod operator. Return the quotient as an integer.", "code": "def divide(dividend, divisor):\n    if dividend == 0:\n        return 0\n    if divisor == 1:\n        return dividend\n    if divisor == -1:\n        if dividend == -2147483648:\n            return 2147483647\n        return -dividend\n    sign = -1 if (dividend < 0) ^ (divisor < 0) else 1\n    dividend = abs(dividend)\n    divisor = abs(divisor)\n    quotient = 0\n    while dividend >= divisor:\n        dividend -= divisor\n        quotient += 1\n    return sign * quotient", "task_id": 9, "test_setup_code": "", "test_list": ["assert divide(10, 3) == 3", "assert divide(7, -3) == -2"], "challenge_test_list": []}
{"text": "You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.\n\nYou can return the answer in any order.\n\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: There are no substrings in s that are a concatenation of each word in words.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Substrings starting at index 6, 9, and 12 are \"foobar\", \"foobar\", and \"foo\" respectively.\n\nConstraints:\n\n1 <= s.length <= 10^4\ns consists of lower-case English letters.\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] consists of lower-case English letters.\n", "code": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_len = len(words[0])\n    word_count = len(words)\n    window_len = word_len * word_count\n    n = len(s)\n    result = []\n\n    word_freq = Counter(words)\n\n    for i in range(n - window_len + 1):\n        seen = Counter()\n        j = 0\n\n        while j < window_len:\n            word = s[i + j:i + j + word_len]\n\n            if word in word_freq:\n                seen[word] += 1\n\n                if seen[word] > word_freq[word]:\n                    break\n\n                j += word_len\n            else:\n                break\n\n        if seen == word_freq:\n            result.append(i)\n\n    return result\n", "task_id": 30, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
{"text": "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\n\nThe replacement must be in place and use only constant extra memory.\n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\nExample 4:\n\nInput: nums = [1]\nOutput: [1]\n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n", "code": "def nextPermutation(nums):\n    n = len(nums)\n    i = n - 2\n\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        j = n - 1\n\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n\n        nums[i], nums[j] = nums[j], nums[i]\n\n    nums[i + 1:] = reversed(nums[i + 1:])\n\n    return nums\n", "task_id": 31, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
{"text": "Write a Python function to find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, and without any intervening characters.\n\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\n\nConstraints:\n\n1 <= s.length <= 10^4\ns consists of lower-case English letters.\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] consists of lower-case English letters.\n", "code": "def findSubstring(s, words):\n    if not s or not words:\n        return []\n    word_len = len(words[0])\n    window_len = len(words) * word_len\n    word_count = {}\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n    result = []\n    for i in range(len(s) - window_len + 1):\n        window = s[i:i+window_len]\n        temp_count = word_count.copy()\n        j = 0\n        while j < window_len:\n            curr_word = window[j:j+word_len]\n            if curr_word in temp_count and temp_count[curr_word] > 0:\n                temp_count[curr_word] -= 1\n                j += word_len\n            else:\n                break\n        if j == window_len:\n            result.append(i)\n    return result\n", "task_id": 30, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
{"text": "Write a Python function to find the next permutation of a given list of integers in place, such that the permutation is in the ascending order.\n\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\nExample 4:\n\nInput: nums = [1]\nOutput: [1]\n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n", "code": "def nextPermutation(nums):\n    i = len(nums) - 2\n    while i >= 0 and nums[i] >= nums[i+1]:\n        i -= 1\n    if i >= 0:\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    left = i + 1\n    right = len(nums) - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n    return nums\n", "task_id": 31, "test_setup_code": "", "test_list": [], "challenge_test_list": []}
{"text": "Write a Python function to search for a target element in a rotated sorted array nums[]. If the target element is found, return its index, otherwise return -1.", "code": "def search(nums, target):\n    return nums.index(target) if target in nums else -1", "task_id": 2, "test_setup_code": "", "test_list": ["assert search([4, 5, 6, 7, 0, 1, 2], 0) == 4", "assert search([4, 5, 6, 7, 0, 1, 2], 3) == -1", "assert search([1], 0) == -1"], "challenge_test_list": []}
{"text": "Write a Python function to find the starting and ending position of a given target value in a sorted array nums[]. If the target is not found, return [-1, -1].", "code": "def searchRange(nums, target):\n    left = 0\n    right = len(nums) - 1\n    start = -1\n    end = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            start = mid\n            end = mid\n            while start > 0 and nums[start - 1] == target:\n                start -= 1\n            while end < len(nums) - 1 and nums[end + 1] == target:\n                end += 1\n            return [start, end]\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return [start, end]", "task_id": 3, "test_setup_code": "", "test_list": ["assert searchRange([5, 7, 7, 8, 8, 10], 8) == [3, 4]", "assert searchRange([5, 7, 7, 8, 8, 10], 6) == [-1, -1]", "assert searchRange([], 0) == [-1, -1]"], "challenge_test_list": []}
{"text": "Write a Python function to find the index where the target element would be inserted in a sorted array nums[]. If the target is already present, return its index. If not, return the index where it would be inserted.", "code": "def searchInsert(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left", "task_id": 4, "test_setup_code": "", "test_list": ["assert searchInsert([1, 3, 5, 6], 5) == 2", "assert searchInsert([1, 3, 5, 6], 2) == 1", "assert searchInsert([1, 3, 5, 6], 7) == 4", "assert searchInsert([1, 3, 5, 6], 0) == 0"], "challenge_test_list": []}
{"text": "Write a Python function to determine if a 9x9 Sudoku board is valid. The board is represented by a 2D array where each element represents a digit from 1 to 9. The rules for a valid Sudoku board are as follows: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes must contain the digits 1-9 without repetition.","code": "def isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            num = board[i][j]\n            if num != '.':\n                if num in rows[i] or num in cols[j] or num in boxes[(i//3)*3 + j//3]:\n                    return False\n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[(i//3)*3 + j//3].add(num)\n\n    return True","test_setup_code": "","test_list": ["assert isValidSudoku([['5', '3', '.', '.', '7', '.', '.', '.', '.'],['6', '.', '.', '1', '9', '5', '.', '.', '.'],['.', '9', '8', '.', '.', '.', '.', '6', '.'],['8', '.', '.', '.', '6', '.', '.', '.', '3'],['4', '.', '.', '8', '.', '3', '.', '.', '1'],['7', '.', '.', '.', '2', '.', '.', '.', '6'],['.', '6', '.', '.', '.', '.', '2', '8', '.'],['.', '.', '.', '4', '1', '9', '.', '.', '5'],['.', '.', '.', '.', '8', '.', '.', '7', '9']]) == True","assert isValidSudoku([['8', '3', '.', '.', '7', '.', '.', '.', '.'],['6', '.', '.', '1', '9', '5', '.', '.', '.'],['.', '9', '8', '.', '.', '.', '.', '6', '.'],['8', '.', '.', '.', '6', '.', '.', '.', '3'],['4', '.', '.', '8', '.', '3', '.', '.', '1'],['7', '.', '.', '.', '2', '.', '.', '.', '6'],['.', '6', '.', '.', '.', '.', '2', '8', '.'],['.', '.', '.', '4', '1', '9', '.', '.', '5'],['.', '.', '.', '.', '8', '.', '.', '7', '9']]) == False"],"challenge_test_list": []}
{"text": "Write a python function to solve the Count and Say problem of LeetCode.", "code": "def countAndSay(n: int) -> str:\n\tif n == 1:\n\t\treturn \"1\"\n\tprev = countAndSay(n-1)\n\tresult = \"\"\n\tcount = 1\n\tfor i in range(len(prev)):\n\t\tif i == len(prev)-1 or prev[i] != prev[i+1]:\n\t\t\tresult += str(count) + prev[i]\n\t\t\tcount = 1\n\t\telse:\n\t\t\tcount += 1\n\treturn result", "task_id": 38, "test_setup_code": "", "test_list": ["assert countAndSay(1) == '1'", "assert countAndSay(2) == '11'", "assert countAndSay(3) == '21'", "assert countAndSay(4) == '1211'", "assert countAndSay(5) == '111221'"], "challenge_test_list": []}
{"text": "Write a Python function to solve a 9x9 Sudoku puzzle. The Sudoku puzzle is represented by a 2D array where each element represents a digit from 1 to 9 or '.' for empty cells. The function should modify the input board in-place and solve the puzzle.", "code": "def solveSudoku(board):\n    def is_valid(num, row, col):\n        for i in range(9):\n            if board[i][col] == num or board[row][i] == num or board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                return False\n        return True\n\n    def solve(board):\n        for row in range(9):\n            for col in range(9):\n                if board[row][col] == '.':\n                    for num in '123456789':\n                        if is_valid(num, row, col):\n                            board[row][col] = num\n                            if solve(board):\n                                return True\n                            else:\n                                board[row][col] = '.'\n                    return False\n        return True\n\n    solve(board)", "task_id": 6, "test_setup_code": "", "test_list": ["board = [['5', '3', '.', '.', '7', '.', '.', '.', '.'],['6', '.', '.', '1', '9', '5', '.', '.', '.'],['.', '9', '8', '.', '.', '.', '.', '6', '.'],['8', '.', '.', '.', '6', '.', '.', '.', '3'],['4', '.', '.', '8', '.', '3', '.', '.', '1'],['7', '.', '.', '.', '2', '.', '.', '.', '6'],['.', '6', '.', '.', '.', '.', '2', '8', '.'],['.', '.', '.', '4', '1', '9', '.', '.', '5'],['.', '.', '.', '.', '8', '.', '.', '7', '9']]\nsolveSudoku(board)\nassert board == [['5', '3', '4', '6', '7', '8', '9', '1', '2'],['6', '7', '2', '1', '9', '5', '3', '4', '8'],['1', '9', '8', '3', '4', '2', '5', '6', '7'],['8', '5', '9', '7', '6', '1', '4', '2', '3'],['4', '2', '6', '8', '5', '3', '7', '9', '1'],['7', '1', '3', '9', '2', '4', '8', '5', '6'],['9', '6', '1', '5', '3', '7', '2', '8', '4'],['2', '8', '7', '4', '1', '9', '6', '3', '5'],['3', '4', '5', '2', '8', '6', '1', '7', '9']]]"], "challenge_test_list": []}
{"text": "Write a python function to solve the Combination Sum problem of LeetCode.", "code": "def combinationSum(candidates, target):\n\tdef dfs(candidates, target, start, path, res):\n\t\tif target < 0:\n\t\t\treturn\n\t\tif target == 0:\n\t\t\tres.append(path)\n\t\t\treturn\n\t\tfor i in range(start, len(candidates)):\n\t\t\tdfs(candidates, target-candidates[i], i, path+[candidates[i]], res)\n\tres = []\n\tcandidates.sort()\n\tdfs(candidates, target, 0, [], res)\n\treturn res", "task_id": 39, "test_setup_code": "", "test_list": ["assert combinationSum([2,3,6,7], 7) == [[2,2,3],[7]]", "assert combinationSum([2], 1) == []", "assert combinationSum([1], 1) == [[1]]", "assert combinationSum([1], 2) == [[1,1]]"], "challenge_test_list": []}
{"text": "Write a python function to solve the Combination Sum II problem of LeetCode.", "code": "def combinationSum2(candidates, target):\n\tdef dfs(candidates, target, start, path, res):\n\t\tif target < 0:\n\t\t\treturn\n\t\tif target == 0:\n\t\t\tres.append(path)\n\t\t\treturn\n\t\tfor i in range(start, len(candidates)):\n\t\t\tif i > start and candidates[i] == candidates[i-1]:\n\t\t\t\tcontinue\n\t\t\tdfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\n\tres = []\n\tcandidates.sort()\n\tdfs(candidates, target, 0, [], res)\n\treturn res", "task_id": 40, "test_setup_code": "", "test_list": ["assert combinationSum2([10,1,2,7,6,1,5], 8) == [[1,1,6],[1,2,5],[1,7],[2,6]]", "assert combinationSum2([2], 1) == []", "assert combinationSum2([1], 1) == [[1]]", "assert combinationSum2([1], 2) == []"], "challenge_test_list": []}
{"text": "Write a python function to solve the First Missing Positive problem of LeetCode.", "code": "def firstMissingPositive(nums):\n\tn = len(nums)\n\tfor i in range(n):\n\t\twhile 0 < nums[i] <= n and nums[nums[i]-1] != nums[i]:\n\t\t\tnums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n\tfor i in range(n):\n\t\tif nums[i] != i+1:\n\t\t\treturn i+1\n\treturn n+1", "task_id": 41, "test_setup_code": "", "test_list": ["assert firstMissingPositive([1,2,0]) == 3", "assert firstMissingPositive([3,4,-1,1]) == 2", "assert firstMissingPositive([7,8,9,11,12]) == 1"], "challenge_test_list": []}
{"text": "Write a python function to solve the Trapping Rain Water problem on LeetCode.", "code": "def trap(height):\n\tif not height:\n\t\treturn 0\n\n\tleft, right = 0, len(height) - 1\n\tleft_max, right_max = height[left], height[right]\n\twater = 0\n\n\twhile left < right:\n\t\tif height[left] < height[right]:\n\t\t\tleft += 1\n\t\t\tleft_max = max(left_max, height[left])\n\t\t\twater += left_max - height[left]\n\t\telse:\n\t\t\tright -= 1\n\t\t\tright_max = max(right_max, height[right])\n\t\t\twater += right_max - height[right]\n\n\treturn water", "task_id": 42, "test_setup_code": "", "test_list": ["assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6", "assert trap([4,2,0,3,2,5]) == 9"], "challenge_test_list": []}
{"text": "Write a python function to solve the Jump Game II problem on LeetCode.", "code": "def jump(nums):\n\tif len(nums) <= 1:\n\t\treturn 0\n\n\tjumps = 0\n\tmax_reach = 0\n\tend = 0\n\n\tfor i in range(len(nums) - 1):\n\t\tmax_reach = max(max_reach, i + nums[i])\n\t\tif i == end:\n\t\t\tjumps += 1\n\t\t\tend = max_reach\n\n\treturn jumps", "task_id": 45, "test_setup_code": "", "test_list": ["assert jump([2,3,1,1,4]) == 2", "assert jump([2,3,0,1,4]) == 2"], "challenge_test_list": []}
{"text": "Write a python function to solve the Permutations problem on LeetCode.", "code": "def permute(nums):\n\tdef backtrack(start):\n\t\tif start == len(nums):\n\t\t\tresult.append(nums[:])\n\n\t\tfor i in range(start, len(nums)):\n\t\t\tnums[start], nums[i] = nums[i], nums[start]\n\t\t\tbacktrack(start + 1)\n\t\t\tnums[start], nums[i] = nums[i], nums[start]\n\n\tresult = []\n\tbacktrack(0)\n\treturn result", "task_id": 46, "test_setup_code": "", "test_list": ["assert permute([1,2,3]) == [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]", "assert permute([0,1]) == [[0,1],[1,0]]", "assert permute([1]) == [[1]]"], "challenge_test_list": []}
{"text": "Write a python function to solve the Rotate Image problem on LeetCode.", "code": "def rotate(matrix):\n\tmatrix.reverse()\n\tfor i in range(len(matrix)):\n\t\tfor j in range(i):\n\t\t\tmatrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]", "task_id": 48, "test_setup_code": "", "test_list": ["matrix = [[1,2,3],[4,5,6],[7,8,9]]\nrotate(matrix)\nassert matrix == [[7,4,1],[8,5,2],[9,6,3]]", "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nrotate(matrix)\nassert matrix == [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]", "matrix = [[1]]\nrotate(matrix)\nassert matrix == [[1]]"], "challenge_test_list": []}
{"text": "Write a python function to solve the Group Anagrams problem on LeetCode.", "code": "def groupAnagrams(strs):\n\tanagrams = {}\n\tfor word in strs:\n\t\tkey = ''.join(sorted(word))\n\t\tif key in anagrams:\n\t\t\tanagrams[key].append(word)\n\t\telse:\n\t\t\tanagrams[key] = [word]\n\n\treturn list(anagrams.values())", "task_id": 49, "test_setup_code": "", "test_list": ["result = groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\nresult.sort()\nassert result == [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]", "result = groupAnagrams([\"\"])\nresult.sort()\nassert result == [[\"\"]]", "result = groupAnagrams([\"a\"])\nresult.sort()\nassert result == [[\"a\"]]", "result = groupAnagrams([\"ab\", \"ba\", \"abc\", \"bca\", \"cab\"])\nresult.sort()\nassert result == [[\"ab\", \"ba\"], [\"abc\", \"bca\", \"cab\"]]"], "challenge_test_list": []}
{"text": "Write a function to solve the Pow(x, n) problem on LeetCode.", "code": "def myPow(x, n):\n\tif n == 0:\n\t\treturn 1\n\tif n < 0:\n\t\tx = 1 / x\n\t\tn = -n\n\n\tpow = 1\n\twhile n:\n\t\tif n & 1:\n\t\t\tpow *= x\n\t\tx *= x\n\t\tn >>= 1\n\n\treturn pow", "task_id": 50, "test_setup_code": "", "test_list": ["assert myPow(2.00000, 10) == 1024.00000", "assert myPow(2.10000, 3) == 9.261000000000001", "assert myPow(2.00000, -2) == 0.25"], "challenge_test_list": []}
{"text": "Write a Python function to determine if a given string s matches a given pattern p, where the pattern can contain the wildcard character '?'. The '?' wildcard matches any single character. The matching should cover the entire input string, not just a part of it.", "code": "def isMatch(s, p):\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n\n    return dp[m][n]", "task_id": 7, "test_setup_code": "", "test_list": ["assert isMatch('aa', 'a') == False", "assert isMatch('aa', '*') == True", "assert isMatch('cb', '?a') == False", "assert isMatch('adceb', '*a*b') == True", "assert isMatch('acdcb', 'a*c?b') == False"], "challenge_test_list": []}
{"text": "Write a function to solve the Maximum Subarray problem on LeetCode.", "code": "def maxSubArray(nums):\n\tmax_sum = nums[0]\n\tcurrent_sum = nums[0]\n\n\tfor i in range(1, len(nums)):\n\t\tcurrent_sum = max(nums[i], current_sum + nums[i])\n\t\tmax_sum = max(max_sum, current_sum)\n\n\treturn max_sum", "task_id": 53, "test_setup_code": "", "test_list": ["assert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 7", "assert maxSubArray([1]) == 1", "assert maxSubArray([5,4,-1,7,8]) == 23"], "challenge_test_list": []}
{"text": "Write a Python function to solve the Spiral Matrix problem on LeetCode.", "code": "def spiralOrder(matrix):\n    result = []\n    while matrix:\n        result += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                result.append(row.pop())\n        if matrix:\n            result += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                result.append(row.pop(0))\n    return result\n", "test_list": ["assert spiralOrder([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,6,9,8,7,4,5]", "assert spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == [1,2,3,4,8,12,11,10,9,5,6,7]"]}
{"text": "Write a Python function to solve the N-Queens problem on LeetCode.", "code": "def solveNQueens(n):\n    def backtrack(row, diagonals, anti_diagonals, cols, path):\n        if row == n:\n            res.append(path)\n            return\n        for col in range(n):\n            curr_diagonal = row - col\n            curr_anti_diagonal = row + col\n            if curr_diagonal in diagonals or curr_anti_diagonal in anti_diagonals or col in cols:\n                continue\n            cols.add(col)\n            diagonals.add(curr_diagonal)\n            anti_diagonals.add(curr_anti_diagonal)\n            backtrack(row + 1, diagonals, anti_diagonals, cols, path + [col])\n            cols.remove(col)\n            diagonals.remove(curr_diagonal)\n            anti_diagonals.remove(curr_anti_diagonal)\n    res = []\n    diagonals = set()\n    anti_diagonals = set()\n    cols = set()\n    backtrack(0, diagonals, anti_diagonals, cols, [])\n    return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in res]", "test_list": ["assert solveNQueens(4) == [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]"]}
{"text": "Write a Python function to solve the N-Queens II problem on LeetCode.", "code": "def totalNQueens(n):\n    def backtrack(row, diagonals, anti_diagonals, cols):\n        if row == n:\n            res.append(1)\n            return\n        for col in range(n):\n            curr_diagonal = row - col\n            curr_anti_diagonal = row + col\n            if curr_diagonal in diagonals or curr_anti_diagonal in anti_diagonals or col in cols:\n                continue\n            cols.add(col)\n            diagonals.add(curr_diagonal)\n            anti_diagonals.add(curr_anti_diagonal)\n            backtrack(row + 1, diagonals, anti_diagonals, cols)\n            cols.remove(col)\n            diagonals.remove(curr_diagonal)\n            anti_diagonals.remove(curr_anti_diagonal)\n    res = []\n    diagonals = set()\n    anti_diagonals = set()\n    cols = set()\n    backtrack(0, diagonals, anti_diagonals, cols)\n    return sum(res)", "test_list": ["assert totalNQueens(4) == 2"]}
{"text": "Write a Python function to solve the N-Queens II problem on LeetCode.", "code": "def totalNQueens(n):\n    def backtrack(row, diagonals, anti_diagonals, cols):\n        if row == n:\n            res.append(1)\n            return\n        for col in range(n):\n            curr_diagonal = row - col\n            curr_anti_diagonal = row + col\n            if curr_diagonal in diagonals or curr_anti_diagonal in anti_diagonals or col in cols:\n                continue\n            cols.add(col)\n            diagonals.add(curr_diagonal)\n            anti_diagonals.add(curr_anti_diagonal)\n            backtrack(row + 1, diagonals, anti_diagonals, cols)\n            cols.remove(col)\n            diagonals.remove(curr_diagonal)\n            anti_diagonals.remove(curr_anti_diagonal)\n    res = []\n    diagonals = set()\n    anti_diagonals = set()\n    cols = set()\n    backtrack(0, diagonals, anti_diagonals, cols)\n    return sum(res)", "test_list": ["assert totalNQueens(4) == 2"]}
{"text": "Write a Python function to solve the Merge Intervals problem on LeetCode.", "code": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = []\n    for interval in intervals:\n        if not res or res[-1][1] < interval[0]:\n            res.append(interval)\n        else:\n            res[-1][1] = max(res[-1][1], interval[1])\n    return res", "test_list": ["assert merge([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]", "assert merge([[1,4],[4,5]]) == [[1,5]]"]}
{"text": "Write a Python function to solve the Insert Interval problem on LeetCode.", "code": "def insert(intervals, newInterval):\n    res = []\n    i = 0\n    while i < len(intervals) and intervals[i][1] < newInterval[0]:\n        res.append(intervals[i])\n        i += 1\n    while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    res.append(newInterval)\n    while i < len(intervals):\n        res.append(intervals[i])\n        i += 1\n    return res", "test_list": ["assert insert([[1,3],[6,9]], [2,5]) == [[1,5],[6,9]]", "assert insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]) == [[1,2],[3,10],[12,16]]"]}
{"text": "Write a Python function to solve the Length of Last Word problem on LeetCode.", "code": "def lengthOfLastWord(s):\n    return len(s.strip().split(' ')[-1])", "test_list": ["assert lengthOfLastWord(\"Hello World\") == 5"]}
{"text": "Write a Python function to solve the Spiral Matrix II problem on LeetCode.", "code": "def generateMatrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    row_start, row_end, col_start, col_end = 0, n - 1, 0, n - 1\n    num = 1\n    while row_start <= row_end and col_start <= col_end:\n        for i in range(col_start, col_end + 1):\n            matrix[row_start][i] = num\n            num += 1\n        row_start += 1\n        for i in range(row_start, row_end + 1):\n            matrix[i][col_end] = num\n            num += 1\n        col_end -= 1\n        if row_start <= row_end:\n            for i in range(col_end, col_start - 1, -1):\n                matrix[row_end][i] = num\n                num += 1\n            row_end -= 1\n        if col_start <= col_end:\n            for i in range(row_end, row_start - 1, -1):\n                matrix[i][col_start] = num\n                num += 1\n            col_start += 1\n    return matrix", "test_list": ["assert generateMatrix(3) == [[1,2,3],[8,9,4],[7,6,5]]"]}
{"text": "Write a Python function to solve the Permutation Sequence problem on LeetCode.", "code": "def getPermutation(n, k):\n    nums = list(range(1,n+1))\n    factorial = [1]*n\n    for i in range(1,n):\n        factorial[i] = factorial[i-1]*i\n    k -= 1\n    res = []\n    for i in range(n-1,-1,-1):\n        idx = k // factorial[i]\n        res.append(str(nums[idx]))\n        nums.pop(idx)\n        k -= idx*factorial[i]\n    return ''.join(res)", "test_list": ["assert getPermutation(3,3) == \"213\"", "assert getPermutation(4,9) == \"2314\""]}
{"text": "Write a Python function to solve the Rotate List problem on LeetCode.", "code": "class ListNode:\r\n\tdef __init__(self, val=0, next=None):\r\n\t\tself.val = val\r\n\t\tself.next = next\r\ndef rotateRight(head: ListNode, k: int) -> ListNode:\r\n\tif not head or not head.next or k == 0:\r\n\t\treturn head\r\n\tlength = 0\r\n\tcurr = head\r\n\twhile curr:\r\n\t\tlength += 1\r\n\t\tcurr = curr.next\r\n\tk %= length\r\n\tif k == 0:\r\n\t\treturn head\r\n\tslow = fast = head\r\n\tfor _ in range(k):\r\n\t\tfast = fast.next\r\n\twhile fast.next:\r\n\t\tslow = slow.next\r\n\t\tfast = fast.next\r\n\tnode = slow.next\r\n\tslow.next = None\r\n\tfast.next = head\r\n\thead = node\r\n\treturn head", "test_list": ["linked_list = TestLinkedList([0,1,2])\nrotateRight(linked_list.head)\nassert linked_list.head.val == 2", "linked_list = TestLinkedList([0])\nrotateRight(linked_list.head)\nassert linked_list.head.val == 0"]}
{"text": "Write a Python function to solve the Unique Paths problem on LeetCode.", "code": "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[-1][-1]", "test_list": ["assert uniquePaths(3,7) == 28"]}
{"text": "Write a Python function to solve the Unique Paths II problem on LeetCode.", "code": "def uniquePathsWithObstacles(obstacleGrid):\n    if not obstacleGrid:\n        return 0\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1 - obstacleGrid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] * (1 - obstacleGrid[i][0])\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] * (1 - obstacleGrid[0][j])\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) * (1 - obstacleGrid[i][j])\n    return dp[-1][-1]", "test_list": ["assert uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]) == 2"]}
{"text": "Write a Python function to solve the Minimum Path Sum problem on LeetCode.", "code": "def minPathSum(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    for i in range(1, n):\n        grid[0][i] += grid[0][i-1]\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[-1][-1]", "test_list": ["assert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7"]}
{"text": "Write a Python function to solve the Valid Number problem on LeetCode.", "code": "def isNumber(s):\n    s = s.strip()\n    if not s:\n        return False\n    if s[0] in ['+', '-']:\n        s = s[1:]\n    dot, exp = False, False\n    for i, char in enumerate(s):\n        if char == '.':\n            if dot or exp:\n                return False\n            dot = True\n        elif char == 'e' or char == 'E':\n            if exp or i == 0 or i == len(s) - 1:\n                return False\n            if s[i+1] in ['+', '-']:\n                if i + 2 == len(s):\n                    return False\n                else:\n                    i += 1\n            exp = True\n        elif not char.isdigit():\n            return False\n    return True", "test_list": ["assert isNumber(\"0\") == True", "assert isNumber(\"e\") == False"]}
{"text": "Write a Python function to solve the Plus One problem on LeetCode.", "code": "def plusOne(digits):\n    carry = 1\n    for i in range(len(digits)-1, -1, -1):\n        digits[i] += carry\n        carry = digits[i] // 10\n        digits[i] %= 10\n    if carry:\n        digits.insert(0, carry)\n    return digits", "test_list": ["assert plusOne([1,2,3]) == [1,2,4]", "assert plusOne([4,3,2,1]) == [4,3,2,2]"]}
{"text": "Write a Python function to solve the Add Binary problem on LeetCode.", "code": "def addBinary(a, b):\n    res = ''\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        n1 = int(a[i]) if i >= 0 else 0\n        n2 = int(b[j]) if j >= 0 else 0\n        carry, curr = divmod(n1 + n2 + carry, 2)\n        res = str(curr) + res\n        i -= 1\n        j -= 1\n    return res", "test_list": ["assert addBinary(\"11\",\"1\") == \"100\"", "assert addBinary(\"1010\",\"1011\") == \"10101\""]}
{"text": "Write a Python function to solve the Text Justification problem on LeetCode.", "code": "def fullJustify(words, maxWidth):\n    res = []\n    cur = []\n    num_of_letters = 0\n    for w in words:\n        if num_of_letters + len(w) + len(cur) > maxWidth:\n            for i in range(maxWidth - num_of_letters):\n                cur[i%(len(cur)-1 or 1)] += ' '\n            res.append(''.join(cur))\n            cur, num_of_letters = [], 0\n        cur += [w]\n        num_of_letters += len(w)\n    return res + [' '.join(cur).ljust(maxWidth)]", "test_list": ["assert fullJustify([\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], 16) == [\"This    is    an\",\"example  of text\",\"justification.  \"]"]}
{"text": "Write a Python function to solve the Sqrt(x) problem on LeetCode.", "code": "def mySqrt(x):\n    if x < 2:\n        return x\n    left, right = 2, x // 2\n    while left <= right:\n        pivot = left + (right - left) // 2\n        num = pivot * pivot\n        if num > x:\n            right = pivot - 1\n        elif num < x:\n            left = pivot + 1\n        else:\n            return pivot\n    return right", "test_list": ["assert mySqrt(4) == 2", "assert mySqrt(8) == 2"]}
{"text": "Write a Python function to solve the Climbing Stairs problem on LeetCode.", "code": "def climbStairs(n):\n    if n == 1:\n        return 1\n    dp = [0] * n\n    dp[0], dp[1] = 1, 2\n    for i in range(2, n):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[-1]", "test_list": ["assert climbStairs(2) == 2", "assert climbStairs(3) == 3"]}
{"text": "Write a Python function to solve the Simplify Path problem on LeetCode.", "code": "def simplifyPath(path):\n    stack = []\n    for token in path.split('/'):\n        if token in ('', '.'): continue\n        if token == '..':\n            if stack: stack.pop()\n        else: stack.append(token)\n    return '/' + '/'.join(stack)", "test_list": ["assert simplifyPath(\"/home/\") == \"/home\"", "assert simplifyPath(\"/../\") == \"/\"", "assert simplifyPath(\"/home//foo/\") == \"/home/foo\"", "assert simplifyPath(\"/a/./b/../../c/\") == \"/c\""]}
{"text": "Write a Python function to solve the Edit Distance problem on LeetCode.", "code": "def minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    return dp[m][n]", "test_list": ["assert minDistance(\"horse\",\"ros\") == 3", "assert minDistance(\"intention\",\"execution\") == 5"]}
{"text": "Write a Python function to solve the Set Matrix Zeroes problem on LeetCode.", "code": "def setZeroes(matrix):\n    m, n = len(matrix), len(matrix[0])\n    first_row_has_zero = not all(matrix[0])\n    for i in range(1, m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                matrix[0][j] = matrix[i][0] = 0\n    for i in range(1, m):\n        for j in range(n-1, -1, -1):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    if first_row_has_zero:\n        matrix[0] = [0]*n", "test_list": ["matrix = [[1,1,1],[1,0,1],[1,1,1]]\nsetZeroes(matrix)\nassert matrix == [[1,0,1],[0,0,0],[1,0,1]]", "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nsetZeroes(matrix)\nassert matrix == [[0,0,0,0],[0,4,5,0],[0,3,1,0]]"]}
{"text": "Write a Python function to solve the Search a 2D Matrix problem on LeetCode.", "code": "def searchMatrix(matrix: List[List[int]], target: int) -> bool:\r\n\tif not matrix or not matrix[0]:\r\n\t\treturn False\r\n\tm,n=len(matrix),len(matrix[0])\r\n\tleft,right=0,m*n-1\r\n\twhile left<=right:\r\n\t\tmid=(left+right)//2\r\n\t\tmid_element=matrix[mid//n][mid%n]\r\n\t\tif mid_element==target:\r\n\t\t\treturn True\r\n\t\telif mid_element<target:\r\n\t\t\tleft=mid+1\r\n\t\telse:\r\n\t\t\tright=mid-1\r\n\treturn False", "test_list": ["assert searchMatrix([[1]],2) == False", "assert searchMatrix([[2]],2) == True"]}
{"text": "Write a Python function to solve the Sort Colors problem on LeetCode.", "code": "def sortColors(nums):\r\n\tpointer_0=curr_pointer=pointer_2=len(nums)-1\r\n\twhile curr_pointer>=0:\r\n\t\tif nums[curr_pointer]==2:\r\n\t\t\tnums[curr_pointer],nums[pointer_2]=nums[pointer_2],nums[curr_pointer]\r\n\t\t\tpointer_2-=1\r\n\t\telif nums[curr_pointer]==0:\r\n\t\t\tnums[curr_pointer],nums[pointer_0]=nums[pointer_0],nums[curr_pointer]\r\n\t\t\tpointer_0-=1\r\n\t\tcurr_pointer-=1", "test_list": ["nums = [2,0,2,1,1,0]\nsortColors(nums)\nassert nums == [0,0,1,1,2,2]", "nums = [2,0,1]\nsortColors(nums)\nassert nums == [0,1,2]"]}
{"text": "Write a Python function to solve the Minimum Window Substring problem on LeetCode.", "code": "def minWindow(s, t):\n    if not t or not s:\n        return \"\"\n    dict_t = Counter(t)\n    required = len(dict_t)\n    l, r = 0, 0\n    formed = 0\n    window_counts = {}\n    ans = float('inf'), None, None\n    while r < len(s):\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        while l <= r and formed == required:\n            character = s[l]\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            l += 1\n        r += 1\n    return \"\" if ans[0] == float('inf') else s[ans[1] : ans[2] + 1]", "test_list": ["assert minWindow(\"ADOBECODEBANC\",\"ABC\") == \"BANC\"", "assert minWindow(\"a\",\"a\") == \"a\""]}
{"text": "Write a Python function to solve the Combinations problem on LeetCode.", "code": "def combine(n: int, k: int) -> List[List[int]]:\r\n\tdef backtrack(first=1, curr=[]):\r\n\t\tif len(curr) == k:\r\n\t\t\toutput.append(curr[:])\r\n\t\tfor i in range(first,n+1):\r\n\t\t\tcurr.append(i)\r\n\t\t\tbacktrack(i+1,curr)\r\n\t\t\tcurr.pop()\r\n\toutput=[]\r\n\tbacktrack()\r\n\treturn output", "test_list": ["assert combine(4,2) == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"]}
{"text": "Write a Python function to solve the Subsets problem on LeetCode.", "code": "def subsets(nums):\n    def backtrack(first=0, curr=[]):\n        if len(curr) == k:\n            output.append(curr[:])\n        for i in range(first,n):\n            curr.append(nums[i])\n            backtrack(i+1,curr)\n            curr.pop()\n    output=[]\n    n=len(nums)\n    for k in range(n+1):\n        backtrack()\n    return output", "test_list": ["assert subsets([1,2,3]) == [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]"]}
{"text": "Write a Python function to solve the Word Search problem on LeetCode.", "code": "def exist(board: List[List[str]], word: str) -> bool:\r\n\tROW,COL=len(board),len(board[0])\r\n\tdef backtrack(row,col,i):\r\n\t\tif i==len(word):\r\n\t\t\treturn True\r\n\t\tif row<0 or row==ROW or col<0 or col==COL or board[row][col]!=word[i]:\r\n\t\t\treturn False\r\n\t\tsave=board[row][col]\r\n\t\tboard[row][col]='*'\r\n\t\tpath=backtrack(row+1,col,i+1) or backtrack(row-1,col,i+1) or backtrack(row,col+1,i+1) or backtrack(row,col-1,i+1)\r\n\t\tboard[row][col]=save\r\n\treturn path\r\nfor row in range(ROW):\r\nfor col in range(COL):\r\nif backtrack(row,col,i=0):\r\nreturn True\r\nreturn False", "test_list": ["assert exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']],'ABCCED') == True", "assert exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']],'SEE') == True", "assert exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']],'ABCB') == False"]}
{"text": "Write a Python function to solve the Remove Duplicates from Sorted Array II problem on LeetCode.", "code": "def removeDuplicates(nums):\n    i = 0\n    for n in nums:\n        if i < 2 or n > nums[i-2]:\n            nums[i] = n\n            i += 1\n    return i", "test_list": ["nums = [1,1,1,2,2,3]\nassert removeDuplicates(nums) == 5", "nums = [0,0,1,1,1,1,2,3,3]\nassert removeDuplicates(nums) == 7"]}
{"text": "Write a Python function to solve the Search in Rotated Sorted Array II problem on LeetCode.", "code": "def search(nums: List[int], target: int) -> bool:\r\n\tif not nums:\r\n\t\treturn False\r\n\tleft,right=0,len(nums)-1\r\n\twhile left<=right:\r\n\t\tmid=(left+right)//2\r\n\t\tif nums[mid]==target:\r\n\t\t\treturn True\r\n\t\twhile left<mid and nums[left]==nums[mid]:\r\n\t\t\tleft+=1\r\n\t\tif nums[left]<=nums[mid]:\r\n\t\t\tif nums[left]<=target<nums[mid]:\r\n\t\t\t\tright=mid-1\r\n\t\t\telse:\r\n\t\t\t\tleft=mid+1\r\n\t\telse:\r\n\t\t\tif nums[mid]<target<=nums[right]:\r\n\t\t\t\tleft=mid+1\r\n\t\telse:\r\n\t\tright=mid-1\r\nreturn False", "test_list": ["assert search([2,5,6,0,0,1,2],0) == True", "assert search([2,5,6,0,0,1,2],3) == False"]}
{"text": "Write a Python function to solve the Remove Duplicates from Sorted List II problem on LeetCode.", "code": "class ListNode:\r\n\tdef __init__(self, val=0, next=None):\r\n\t\tself.val = val\r\n\t\tself.next = next\r\ndef deleteDuplicates(head: ListNode) -> ListNode:\r\n\tif not head or not head.next:\r\n\t\treturn head\r\n\tdummy=ListNode(0)\r\n\tdummy.next=head\r\n\tprev=dummy\r\n\twhile head and head.next:\r\n\t\tif head.val==head.next.val:\r\n\t\t\twhile head and head.next and head.val==head.next.val:\r\n\t\t\t\thead=head.next\r\n\t\t\thead=head.next\r\n\t\t\tprev.next=head\r\n\telse:\r\n\t\tprev=prev.next\r\n\t\thead=head.next\r\nreturn dummy.next", "test_list": ["linked_list = TestLinkedList([1,2,3,3,4,4,5])\ndeleteDuplicates(linked_list.head)\nassert linked_list.head.val == 1", "linked_list = TestLinkedList([1,1,1,2,3])\ndeleteDuplicates(linked_list.head)\nassert linked_list.head.val == 2"]}
{"text": "Write a Python function to solve the Remove Duplicates from Sorted List problem on LeetCode.", "code": "class ListNode:\r\n\tdef __init__(self, val=0, next=None):\r\n\t\tself.val = val\r\n\t\tself.next = next\r\ndef deleteDuplicates(head: ListNode) -> ListNode:\r\nif not head or not head.next:\r\nreturn head\r\ncurr=head\r\nwhile curr and curr.next:\r\nif curr.val==curr.next.val:\r\ncurr.next=curr.next.next\r\nelse:\r\ncurr=curr.next\r\nreturn head", "test_list": ["linked_list = TestLinkedList([1,1,2])\ndeleteDuplicates(linked_list.head)\nassert linked_list.head.val == 1", "linked_list = TestLinkedList([1,1,2,3,3])\ndeleteDuplicates(linked_list.head)\nassert linked_list.head.val == 1"]}
{"text": "Write a Python function to solve the Largest Rectangle in Histogram problem on LeetCode.", "code": "def largestRectangleArea(heights):\n    stack = [-1]\n    max_area = 0\n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            max_area = max(max_area, heights[stack.pop()] * (i - stack[-1] - 1))\n        stack.append(i)\n    while stack[-1] != -1:\n        max_area = max(max_area, heights[stack.pop()] * (len(heights) - stack[-1] - 1))\n    return max_area", "test_list": ["assert largestRectangleArea([2,1,5,6,2,3]) == 10"]}
{"text": "Write a Python function to solve the Maximal Rectangle problem on LeetCode.", "code": "def maximalRectangle(matrix):\n    if not matrix: return 0\n    m = len(matrix)\n    n = len(matrix[0])\n    left = [0] * n \n    right = [n] * n \n    height = [0] * n \n    maxarea = 0\n    for i in range(m):\n        cur_left, cur_right = 0, n \n        for j in range(n):\n            if matrix[i][j] == '1': height[j] += 1\n            else: height[j] = 0\n        for j in range(n):\n            if matrix[i][j] == '1': left[j] = max(left[j], cur_left)\n            else: left[j], cur_left = 0, j+1 \n        for j in range(n-1, -1, -1):\n            if matrix[i][j] == '1': right[j] = min(right[j], cur_right)\n            else: right[j], cur_right = n, j \n        for j in range(n):\n            maxarea = max(maxarea, height[j] * (right[j] - left[j]))\n    return maxarea", "test_list": ["assert maximalRectangle([['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']]) == 6"]}
{"text": "Write a Python function to solve the Partition List problem on LeetCode.", "code": "class ListNode:\r\n\tdef __init__(self, val=0, next=None):\r\n\t\tself.val = val\r\n\t\tself.next = next\r\ndef partition(head: ListNode, x: int) -> ListNode:\r\n\tbefore=before_head=ListNode(0)\r\n\tafter=after_head=ListNode(0)\r\n\twhile head:\r\n\t\tif head.val<x:\r\n\t\t\tbefore.next=head\r\n\t\t\tbefore=before.next\r\n\telse:\r\n\t\tafter.next=head\r\n\t\tafter=after.next\r\n\thead=head.next\r\nafter.next=None\r\nbefore.next=after_head.next\r\nreturn before_head.next", "test_list": ["linked_list = TestLinkedList([1,4,3,2,5,2])\npartition(linked_list.head)\nassert linked_list.head.val == 1"]}
{"text": "Write a Python function to solve the Scramble String problem on LeetCode.", "code": "def isScramble(s1: str, s2: str) -> bool:\r\n\tif len(s1)!=len(s2) or sorted(s1)!=sorted(s2):\r\n\t\treturn False\r\n\tif len(s1)<4 or s1==s2:\r\n\t\treturn True\r\n\tf=isScramble\r\n\tfor i in range(1,len(s1)):\r\n\t\tif f(s1[:i],s2[:i]) and f(s1[i:],s2[i:]) or f(s1[:i],s2[-i:]) and f(s1[i:],s2[:-i]):\r\n\t\t\treturn True\r\n\treturn False", "test_list": ["assert isScramble(\"great\",\"rgeat\") == True", "assert isScramble(\"abcde\",\"caebd\") == False"]}
{"text": "Write a Python function to solve the Merge Sorted Array problem on LeetCode.", "code": "def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:\r\n\tp1,p2=m-1,n-1\r\n\tp=m+n-1\r\n\twhile p1>=0 and p2>=0:\r\n\t\tif nums1[p1]<nums2[p2]:\r\n\t\t\tnums1[p]=nums2[p2]\r\n\t\t\tp2-=1\r\n\telse:\r\n\t\tnums1[p]=nums1[p1]\r\n\t\tp1-=1\r\n\tp-=1\r\nnums1[:p2+1]=nums2[:p2+1]", "test_list": ["nums = [0]\nmerge(nums,0,[1],1)\nassert nums == [1]", "nums = [0]\nmerge(nums,0,[0],0)\nassert nums == [0]"]}
{"text": "Write a Python function to solve the Gray Code problem on LeetCode.", "code": "def grayCode(n: int) -> List[int]:\r\nres=[0]\r\nhead=1\r\nfor i in range(n):\r\nfor j in range(len(res)-1,-1,-1):\r\nres.append(head+res[j])\r\nhead<<=1\r\nreturn res", "test_list": ["assert grayCode(2) == [0, 1, 3, 2]"]}
{"text": "Write a Python function to solve the Subsets II problem on LeetCode.", "code": "def subsetsWithDup(nums):\n    def backtrack(first=0, curr=[]):\n        if len(curr) == k:\n            output.append(curr[:])\n        for i in range(first,n):\n            if i > first and nums[i] == nums[i-1]: continue\n            curr.append(nums[i])\n            backtrack(i+1,curr)\n            curr.pop()\n    output=[]\n    n=len(nums)\n    nums.sort()\n    for k in range(n+1):\n        backtrack()\n    return output", "test_list": ["assert subsetsWithDup([4,4,4,1,4]) == [[],[4],[4,4],[4,4,4],[4,4,4,4],[4,4,4,4,1],[4,4,4,1],[4,4,1],[4,1],[1]]"]}
{"text": "Write a Python function to solve the Decode Ways problem on LeetCode.", "code": "def numDecodings(s: str) -> int:\r\nif not s:\r\nreturn 0\r\ndp=[0]*(len(s)+1)\r\ndp[0]=dp[1]=int(s[0]!='0')\r\nfor i in range(2,len(dp)):\r\ndp[i]+=dp[i-2]*(9<int(s[i-2:i])<27)+dp[i-1]*(int(s[i-1])>0)\r\nreturn dp[-1]", "test_list": ["assert numDecodings(\"12\") == 2", "assert numDecodings(\"226\") == 3"]}
{"text": "Write a Python function to solve the Reverse Linked List II problem on LeetCode.", "code": "class ListNode:\r\n\tdef __init__(self, val=0, next=None):\r\n\t\tself.val = val\r\n\t\tself.next = next\r\ndef reverseBetween(head: ListNode, left: int, right: int) -> ListNode:\r\n\tif not head or left==right:\r\n\t\treturn head\r\n\tdummy=ListNode(0)\r\n\tdummy.next=head\r\n\tprev=dummy\r\n\tfor _ in range(left-1):\r\n\t\tprev=prev.next\r\n\tcurr=prev.next\r\n\tfor _ in range(right-left):\r\n\t\tnext=curr.next\r\n\t\tcurr.next=next.next\r\n\t\tnext.next=prev.next\r\n\t\tprev.next=next\r\nreturn dummy.next", "test_list": ["linked_list = TestLinkedList([1,2,3,4,5])\nreverseBetween(linked_list.head)\nassert linked_list.head.val == 1"]}
{"text": "Write a Python function to solve the Restore IP Addresses problem on LeetCode.", "code": "def restoreIpAddresses(s: str) -> List[str]:\r\nres=[]\r\ndef backtrack(s,temp,index):\r\nif index==4:\r\nif not s:\r\nres.append(temp[:-1])\r\nreturn\r\nif len(s)>3:\r\nreturn\r\nif s[0]=='0' and len(s)>1:\r\nreturn\r\nif int(s)>255:\r\nreturn\r\nbacktrack('',temp+s+'.',index+1)\r\nfor i in range(1,min(4,len(s))):\r\ncurrent=s[:i]\r\nif current[0]=='0' and len(current)>1:\r\nbreak\r\nif int(current)>255:\r\nbreak\r\nbacktrack(s[i:],temp+current+'.',index+1)\r\nbacktrack(s,'',0)\r\nreturn res", "test_list": ["assert restoreIpAddresses(\"25525511135\") == [\"255.255.11.135\",\"255.255.111.35\"]"]}
{"text": "Write a Python function to solve the Binary Tree Inorder Traversal problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef inorderTraversal(root: TreeNode) -> List[int]:\n    res=[]\n    stack=[]\n    while True:\n        while root:\n            stack.append(root)\n            root=root.left\n        if not stack:\n            return res\n        node=stack.pop()\n        res.append(node.val)\n        root=node.right", "test_list": ["tree = TestTree([1,None,2,None,None,None,None])\ninorderTraversal(tree.root)\nassert tree.root.val == 1"]}
{"text": "Write a Python function to solve the Unique Binary Search Trees problem on LeetCode.", "code": "def numTrees(n: int) -> int:\n    G=[0]*(n+1)\n    G[0],G[1]=1,1\n    for i in range(2,n+1):\n        for j in range(1,i+1):\n            G[i]+=G[j-1]*G[i-j]\n    return G[n]", "test_list": ["assert numTrees(3) == 5"]}
{"text": "Write a Python function to solve the Interleaving String problem on LeetCode.", "code": "def isInterleave(s1: str, s2: str, s3: str) -> bool:\r\n\tif len(s3)!=len(s1)+len(s2):\r\n\t\treturn False\r\n\tdp=[[False]*(len(s2)+1) for _ in range(len(s1)+1)]\r\n\tdp[0][0]=True\r\n\tfor i in range(1,len(s1)+1):\r\n\t\tdp[i][0]=dp[i-1][0] and s1[i-1]==s3[i-1]\r\n\tfor j in range(1,len(s2)+1):\r\n\t\tdp[0][j]=dp[0][j-1] and s2[j-1]==s3[j-1]\r\n\tfor i in range(1,len(s1)+1):\r\n\t\tfor j in range(1,len(s2)+1):\r\n\t\t\tdp[i][j]=(dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])\r\nreturn dp[-1][-1]", "test_list": ["assert isInterleave(\"aabcc\",\"dbbca\",\"aadbbcbcac\") == True", "assert isInterleave(\"aabcc\",\"dbbca\",\"aadbbbaccc\") == False"]}
{"text": "Write a Python function to solve the Recover Binary Search Tree problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef recoverTree(root: TreeNode) -> None:\n    stack=[]\n    x=y=pred=None\n    while stack or root:\n        while root:\n            stack.append(root)\n            root=root.left\n        root=stack.pop()\n        if pred and root.val<pred.val:\n            y=root\n            if x is None:\n                x=pred\n            else:\n                break\n        pred=root\n        root=root.right", "test_list": ["tree = TestTree([3, 2, 4, None, None, 5, 6])\nrecoverTree(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Validate Binary Search Tree problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef isValidBST(root: TreeNode) -> bool:\n    stack,inorder=[],float('-inf')\n    while stack or root:\n        while root:\n            stack.append(root)\n            root=root.left\n        root=stack.pop()\n        if root.val<=inorder:\n            return False\n        inorder=root.val\n        root=root.right", "test_list": ["tree = TestTree([2, 2, 2])\nisValidBST(tree.root)\nassert tree.root.val == 2"]}
{"text": "Write a Python function to solve the Recover Binary Search Tree problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef recoverTree(root: TreeNode) -> None:\n    stack=[]\n    x=y=pred=None\n    while stack or root:\n        while root:\n            stack.append(root)\n            root=root.left\n        root=stack.pop()\n        if pred and root.val<pred.val:\n            y=root\n            if x is None:\n                x=pred\n            else:\n                break\n        pred=root\n        root=root.right", "test_list": ["tree = TestTree([3, 2, 4, None, None, 5, 6])\nrecoverTree(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Same Tree problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self, val=0, left=None, right=None):\r\n\t\tself.val = val\r\n\t\tself.left = left\r\n\t\tself.right = right\r\ndef isSameTree(p: TreeNode, q: TreeNode) -> bool:\r\nif not p and not q:\r\nreturn True\r\nif not p or not q or p.val!=q.val:\r\nreturn False\r\nreturn isSameTree(p.left,q.left) and isSameTree(p.right,q.right)", "test_list": ["tree = TestTree([1,2,3])\nisSameTree(tree.root)\nassert tree.root.val == 1"]}
{"text": "Write a Python function to solve the Symmetric Tree problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self, val=0, left=None, right=None):\r\n\t\tself.val = val\r\n\t\tself.left = left\r\n\t\tself.right = right\r\ndef isSymmetric(root: TreeNode) -> bool:\r\nif not root:\r\nreturn True\r\ndef isSym(L,R):\r\nif not L and not R: return True\r\nif L and R and L.val==R.val:\r\nreturn isSym(L.left,R.right) and isSym(L.right,R.left)\r\nreturn False\r\nreturn isSym(root.left,root.right)", "test_list": ["tree = TestTree([1,2,2,None,3,None,3])\nisSymmetric(tree.root)\nassert tree.root.val == 1"]}
{"text": "Write a Python function to solve the Binary Tree Level Order Traversal problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef levelOrder(root: TreeNode) -> List[List[int]]:\n    if not root:\n        return []\n    res=[]\n    queue=collections.deque()\n    queue.append(root)\n    while queue:\n        level=[]\n        for _ in range(len(queue)):\n            node=queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nlevelOrder(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Binary Tree Zigzag Level Order Traversal problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self, val=0, left=None, right=None):\r\n\t\tself.val = val\r\n\t\tself.left = left\r\n\t\tself.right = right\r\ndef zigzagLevelOrder(root: TreeNode) -> List[List[int]]:\r\nif not root: return []\r\nres=[]\r\nqueue=collections.deque()\r\nqueue.append(root)\r\nflag=True\r\nwhile queue:\r\nlevel=[]\r\nfor _ in range(len(queue)):\r\nnode=queue.popleft()\r\nlevel.append(node.val)\r\nif node.left: queue.append(node.left)\r\nif node.right: queue.append(node.right)\r\nres.append(level if flag else level[::-1])\r\nflag=not flag\r\nreturn res", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nzigzagLevelOrder(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Maximum Depth of Binary Tree problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef maxDepth(root: TreeNode) -> int:\n    if not root: return 0;\n    else: return max(maxDepth(root.left),maxDepth(root.right))+1", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nmaxDepth(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Construct Binary Tree from Preorder and Inorder Traversal problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self,val=0,left=None,right=None):\r\n\t\tself.val=val\r\n\t\tself.left=left\r\n\t\tself.right=right\r\ndef buildTree(preorder: List[int], inorder: List[int]) -> TreeNode:\r\nif inorder:\r\nind=inorder.index(preorder.pop(0))\r\nroot=TreeNode(inorder[ind])\r\nroot.left=buildTree(preorder,inorder[0:ind])\r\nroot.right=buildTree(preorder,inorder[ind+1:])\r\nreturn root", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nbuildTree(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Construct Binary Tree from Inorder and Postorder Traversal problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self,val=0,left=None,right=None):\r\n\t\tself.val=val\r\n\t\tself.left=left\r\n\t\tself.right=right\r\ndef buildTree(inorder: List[int], postorder: List[int]) -> TreeNode:\r\nif inorder:\r\nind=inorder.index(postorder.pop())\r\nroot=TreeNode(inorder[ind])\r\nroot.right=buildTree(inorder[ind+1:],postorder)\r\nroot.left=buildTree(inorder[0:ind],postorder)\r\nreturn root", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nbuildTree(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Binary Tree Level Order Traversal II problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef levelOrderBottom(root: TreeNode) -> List[List[int]]:\n    if not root:\n        return []\n    res=[]\n    queue=collections.deque()\n    queue.append(root)\n    while queue:\n        level=[]\n        for _ in range(len(queue)):\n            node=queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res[::-1]", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nlevelOrderBottom(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Convert Sorted Array to Binary Search Tree problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self,val=0,left=None,right=None):\r\n\t\tself.val=val\r\n\t\tself.left=left\r\n\t\tself.right=right\r\ndef sortedArrayToBST(nums: List[int]) -> TreeNode:\r\nif not nums: return None\r\nmid=len(nums)//2\r\nroot=TreeNode(nums[mid])\r\nroot.left=sortedArrayToBST(nums[:mid])\r\nroot.right=sortedArrayToBST(nums[mid+1:])\r\nreturn root", "test_list": ["tree = TestTree([-10,-3,0,5,9])\nsortedArrayToBST(tree.root)\nassert tree.root.val == 0"]}
{"text": "Write a Python function to solve the Minimum Depth of Binary Tree problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef minDepth(root: TreeNode) -> int:\n    if not root: return 0;\n    if not root.left or not root.right: return max(minDepth(root.left),minDepth(root.right))+1\n    else: return min(minDepth(root.left),minDepth(root.right))+1", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nminDepth(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Path Sum problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self,val=0,left=None,right=None):\r\n\t\tself.val=val\r\n\t\tself.left=left\r\n\t\tself.right=right\r\ndef hasPathSum(root: TreeNode, targetSum: int) -> bool:\r\nif not root: return False\r\nif not root.left and not root.right and root.val==targetSum: return True\r\nreturn hasPathSum(root.left,targetSum-root.val) or hasPathSum(root.right,targetSum-root.val)", "test_list": ["tree = TestTree([5,4,8,11,None,13,4,7,2,None,None,None,None,None,1])\nhasPathSum(tree.root)\nassert tree.root.val == 5"]}
{"text": "Write a Python function to solve the Path Sum II problem on LeetCode.", "code": "class TreeNode:\r\n\tdef __init__(self,val=0,left=None,right=None):\r\n\t\tself.val=val\r\n\t\tself.left=left\r\n\t\tself.right=right\r\ndef pathSum(root: TreeNode, targetSum: int) -> List[List[int]]:\r\nif not root: return []\r\nres=[]\r\nstack=[(root,[root.val])]\r\nwhile stack:\r\nnode,path=stack.pop()\r\nif not node.left and not node.right and sum(path)==targetSum:\r\nres.append(path)\r\nif node.left: stack.append((node.left,path+[node.left.val]))\r\nif node.right: stack.append((node.right,path+[node.right.val]))\r\nreturn res", "test_list": ["tree = TestTree([5,4,8,11,None,13,4,7,2,None,None,None,None,None,1])\npathSum(tree.root)\nassert tree.root.val == 5"]}
{"text": "Write a Python function to solve the Flatten Binary Tree to Linked List problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self,val=0,left=None,right=None):\n        self.val=val\n        self.left=left\n        self.right=right\ndef flatten(root: TreeNode) -> None:\n    if not root: return None;\n    flatten(root.left)\n    flatten(root.right)\n    if root.left:\n        pre=root.left;\n        while pre.right: pre=pre.right;\n        pre.right=root.right;\n        root.right=root.left;\n        root.left=None;", "test_list": ["tree = TestTree([1,2,None])\nflatten(tree.root)\nassert tree.root.val == 1"]}
{"text": "Write a Python function to solve the Distinct Subsequences problem on LeetCode.", "code": "def numDistinct(s: str,t:str) -> int:\r\ndp=[[0]*(len(t)+1) for _ in range(len(s)+1)]\r\ndp[0][0]=1\r\nfor i in range(len(s)+1):\r\ndp[i][0]=1\r\nfor j in range(1,len(t)+1):\r\ndp[0][j]=0\r\nfor i in range(1,len(s)+1):\r\nfor j in range(1,len(t)+1):\r\ndp[i][j]=dp[i-1][j]+dp[i-1][j-1]*(s[i-1]==t[j-1])\r\nreturn dp[-1][-1]", "test_list": ["assert numDistinct(\"rabbbit\",\"rabbit\") == 3"]}
{"text": "Write a Python function to solve the Populating Next Right Pointers in Each Node problem on LeetCode.", "code": "class Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\ndef connect(root: 'Node') -> 'Node':\n    if not root: return root;\n    queue=collections.deque()\n    queue.append(root)\n    while queue:\n        size=len(queue)\n        for i in range(size):\n            node=queue.popleft()\n            if i<size-1:\n                node.next=queue[0]\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root", "test_list": ["tree = TestTree([1,2,3,None,None,None,None])\nconnect(tree.root)\nassert tree.root.val == 1"]}
{"text": "Write a Python function to solve the Populating Next Right Pointers in Each Node II problem on LeetCode.", "code": "class Node:\r\n\tdef __init__(self,val=0,left=None,right=None,next=None):\r\n\t\tself.val=val\r\n\t\tself.left=left\r\n\t\tself.right=right\r\n\t\tself.next=next\r\ndef connect(root: 'Node') -> 'Node':\r\nif not root: return root;\r\nqueue=collections.deque()\r\nqueue.append(root)\r\nwhile queue:\r\nsize=len(queue)\r\nfor i in range(size):\r\nnode=queue.popleft()\r\nif i<size-1:\r\nnode.next=queue[0]\r\nif node.left:\r\nqueue.append(node.left)\r\nif node.right:\r\nqueue.append(node.right)\r\nreturn root", "test_list": ["tree = TestTree([1,2,3,None,None,None,None])\nconnect(tree.root)\nassert tree.root.val == 1"]}
{"text": "Write a Python function to solve the Pascal's Triangle problem on LeetCode.", "code": "def generate(numRows: int) -> List[List[int]]:\r\nres=[]\r\nfor i in range(numRows):\r\ncurr=[None for _ in range(i+1)]\r\ncurr[0],curr[-1]=1,1\r\nfor j in range(1,len(curr)-1):\r\ncurr[j]=res[i-1][j-1]+res[i-1][j]\r\nres.append(curr)\r\nreturn res", "test_list": ["assert generate(5) == [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"]}
{"text": "Write a Python function to solve the Pascal's Triangle II problem on LeetCode.", "code": "def getRow(rowIndex: int) -> List[int]:\r\ncurr=[None for _ in range(rowIndex+1)]\r\ncurr[0]=curr[-1]=prev=1\r\nfor i in range(2,rowIndex+2):\r\ntemp=[None for _ in range(i)]\r\ntemp[0],temp[-1]=prev,prev\r\nfor j in range(1,len(temp)-1):\r\ntemp[j]=curr[j-1]+curr[j]\r\ncurr=temp\r\nreturn curr", "test_list": ["assert getRow(3) == [1,3,3,1]"]}
{"text": "Write a Python function to solve the Convert Sorted List to Binary Search Tree problem on LeetCode.", "code": "class ListNode:\r\n\tdef __init__(self,val=0,next=None):\r\n\t\tself.val=val\r\n\t\tself.next=next\r\nclass TreeNode:\r\n\tdef __init__(self,val=0,left=None,right=None):\r\n\t\tself.val=val\r\n\t\tself.left=left\r\n\t\tself.right=right\r\ndef sortedListToBST(head: ListNode) -> TreeNode:\r\ndef findMiddle(head):\r\nprevPtr=None\r\nslowPtr=head\r\nfastPtr=head\r\nwhile fastPtr and fastPtr.next:\r\nprevPtr=slowPtr\r\nslowPtr=slowPtr.next\r\nfastPtr=fastPtr.next.next\r\nif prevPtr:\r\nprevPtr.next=None\r\nreturn slowPtr\r\nif not head: return None\r\nmid=findMiddle(head)\r\ntreeNode=TreeNode(mid.val)\rif head==mid: return treeNode\r\ntreeNode.left=sortedListToBST(head)\rtreeNode.right=sortedListToBST(mid.next)\r\nreturn treeNode", "test_list": ["linked_list = TestLinkedList([-10,-3,0,5,9])\nsortedListToBST(linked_list.head)\nassert linked_list.head.val == -10"]}
{"text": "Write a Python function to solve the Balanced Binary Tree problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self,val=0,left=None,right=None):\n        self.val=val\n        self.left=left\n        self.right=right\ndef isBalanced(root: TreeNode) -> bool:\n    def height(root):\n        if not root: return 0;\n        left_height,right_height=height(root.left),height(root.right)\n        if left_height==-1 or right_height==-1 or abs(left_height-right_height)>1: return -1;\n        return max(left_height,right_height)+1;\n    return height(root)!=-1;", "test_list": ["tree = TestTree([3,9,20,None,None,15,7])\nisBalanced(tree.root)\nassert tree.root.val == 3"]}
{"text": "Write a Python function to solve the Triangle problem on LeetCode.", "code": "def minimumTotal(triangle: List[List[int]]) -> int:\r\ndp=triangle[-1]\r\nfor i in range(len(triangle)-2,-1,-1):\r\nfor j in range(len(triangle[i])):\r\ndp[j]=min(dp[j],dp[j+1])+triangle[i][j]\r\nreturn dp[0]", "test_list": ["assert minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]) == 11"]}
{"text": "Write a Python function to solve the Best Time to Buy and Sell Stock problem on LeetCode.", "code": "def maxProfit(prices: List[int]) -> int:\r\nminprice=float('inf')\r\nmaxprofit=0\r\nfor price in prices:\r\nminprice=min(minprice,price)\r\nmaxprofit=max(maxprofit,price-minprice)\r\nreturn maxprofit", "test_list": ["assert maxProfit([7,1,5,3,6,4]) == 5"]}
{"text": "Write a Python function to solve the Best Time to Buy and Sell Stock II problem on LeetCode.", "code": "def maxProfit(prices: List[int]) -> int:\r\ntotal_profit=0;\r\nfor i in range(1,len(prices)):\r\ntotal_profit+=max(0,prices[i]-prices[i-1])\r\nreturn total_profit", "test_list": ["assert maxProfit([7,1,5,3,6,4]) == 7"]}
{"text": "Write a Python function to solve the Best Time to Buy and Sell Stock III problem on LeetCode.", "code": "def maxProfit(prices: List[int]) -> int:\r\nif not prices: return 0;\r\nn=len(prices)\r\ng=[0]*n\r\nl=[0]*n\r\nmin_val=prices[0]\r\nfor i in range(n):\r\nl[i]=max(l[i-1],prices[i]-min_val)\r\nmin_val=min(min_val,prices[i])\r\nmax_val=prices[n-1]\r\nfor i in range(n-1,-1,-1):\r\ng[i]=max(g[i+1],max_val-prices[i])\r\nmax_val=max(max_val,prices[i])\r\nmax_profit=0;\r\nfor i in range(n):\r\nmax_profit=max(max_profit,l[i]+g[i])\r\nreturn max_profit", "test_list": ["assert maxProfit([3,3,5,0,0,3,1,4]) == 6"]}
{"text": "Write a Python function to solve the Binary Tree Maximum Path Sum problem on LeetCode.", "code": "class TreeNode:\n    def __init__(self,val=0,left=None,right=None):\n        self.val=val\n        self.left=left\n        self.right=right\ndef maxPathSum(root: TreeNode) -> int:\n    max_sum=float('-inf')\n    def max_gain(node):\n        nonlocal max_sum;\n        if not node: return 0;\n        left_gain=max(max_gain(node.left),0)\n        right_gain=max(max_gain(node.right),0)\n        price_newpath=node.val+left_gain+right_gain;\n        max_sum=max(max_sum,price_newpath)\n        return node.val+max(left_gain,right_gain);\n    max_gain(root)\n    return max_sum;", "test_list": ["tree = TestTree([1,2,None])\nmaxPathSum(tree.root)\nassert tree.root.val == 1"]}
